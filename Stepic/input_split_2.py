# Напишите программу,
# на вход которой подаётся список чисел одной строкой.
# Программа должна для каждого элемента этого списка вывести сумму двух его соседей.
# Для элементов списка, являющихся крайними, одним из соседей считается элемент,
# находящий на противоположном конце этого списка. Например, если на вход подаётся список "1 3 5 6 10",
# то на выход ожидается список "13 6 9 15 7" (без кавычек).
#
# Если на вход пришло только одно число, надо вывести его же.
#
# Вывод должен содержать одну строку с числами нового списка, разделёнными пробелом.
#
# Sample Input 1:
#
# 1 3 5 6 10
# Sample Output 1:
#
# 13 6 9 15 7
# Sample Input 2:
#
# 10
# Sample Output 2:
#
# 10
x = list(map(int, input().split()))
if len(x)>1:
    y = [x[-1] + x[1]]
    for i in range(1, len(x) - 1):
        y.append(x[i - 1] + x[i + 1])
    y.append(x[0]+x[len(x)-2])
else:
    y=x
print(*y)
# a=[int(i) for i in input().split()]
# if len(a)>1:
#     for i in range(len(a)):
#         print(a[i-1]+a[i+1-len(a)])
# else:
#     print(a[0])
# src = [int(i) for i in input().split()]
# if len(src) == 1:
#     print(src[0])
# else:
#     [print( src[i-1] + src[(i+1) % len(src)] ,end=' ') for i in range(len(src))]
#     # выражение src[(i+1) % len(src)] на выходе для src = [1, 3, 5, 6, 10] даст [3, 5, 6, 10, 1]
#     # потому, что (i+1) % len(src) даёт 1 2 3 4 0
#     # т.е. таким образом 0й элемент оказывается в конце списка (как будто повернули циферблат)
#     # таким образом если при обращении к i+1 случится выход за границу диапазона для последнего элемента
#     # то при обращении к (i+1) % len(src) элементу выхода не произойдет
#     # поэтому складывая -1й элемент с [(i+1) % len(src)]-тым элементом
#     # мы выполним условие найти сумму предыдущего и следующего элементов
#     # [print( src[(i+1) % len(src)]) for i in range(len(src))]

# # put your python code here
# a = [int(i) for i in input().split()]
# b = len(a)
# [print(a[i-1]*(1-(b==1))+a[i-(b-1)], end = ' ') for i in range(0, b)]